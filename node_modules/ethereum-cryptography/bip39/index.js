"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
const pbkdf2_1 = require("@noble/hashes/pbkdf2");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const utils_1 = require("@noble/hashes/utils");
const micro_base_1 = require("micro-base");
const isJapanese = (wordlist) => wordlist[0] === "\u3042\u3044\u3053\u304f\u3057\u3093"; // Japanese wordlist
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
const nfkd = (str) => str.normalize("NFKD");
function assertMnemonic(mnemonic) {
    if (typeof mnemonic !== "string") {
        throw new TypeError(`Invalid mnemonic type: ${typeof mnemonic}`);
    }
}
function generateMnemonic(wordlist, strength = 128) {
    (0, utils_1.assertNumber)(strength);
    if (strength % 32 !== 0) {
        throw new TypeError("Invalid entropy");
    }
    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
const checksum = (entropy) => {
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) ||
        wordlist.length !== 2 ** 11 ||
        typeof wordlist[0] !== "string") {
        throw new Error("Worlist: expected array of 2048 strings");
    }
    for (const i of wordlist) {
        if (typeof i !== "string") {
            throw new Error(`Wordlist: non-string element: ${i}`);
        }
    }
    return micro_base_1.utils.chain(micro_base_1.utils.checksum(1, checksum), micro_base_1.utils.radix2(11, true), micro_base_1.utils.alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
    assertMnemonic(mnemonic);
    const words = nfkd(mnemonic).split(" ");
    if (![12, 15, 18, 21, 24].includes(words.length)) {
        throw new Error("Invalid mnemonic");
    }
    const entropy = getCoder(wordlist).decode(words);
    (0, utils_1.assertBytes)(entropy, 16, 20, 24, 28, 32);
    return entropy;
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    (0, utils_1.assertBytes)(entropy, 16, 20, 24, 28, 32);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? "\u3000" : " ");
}
exports.entropyToMnemonic = entropyToMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
const salt = (passphrase = "") => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeed(mnemonic, passphrase = "") {
    assertMnemonic(mnemonic);
    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, nfkd(mnemonic), salt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToSeedSync(mnemonic, passphrase = "") {
    assertMnemonic(mnemonic);
    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, nfkd(mnemonic), salt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
//# sourceMappingURL=index.js.map