"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.findCompoundToken = exports.getTokenById = exports.hasTokenId = exports.findTokenByAddressInCurrency = exports.findTokenByAddress = exports.findTokenById = exports.findTokenByTicker = exports.listTokenTypesForCryptoCurrency = exports.listTokensForCryptoCurrency = exports.listTokens = void 0;
var currencies_1 = require("./currencies");
var erc20_1 = __importDefault(require("../data/erc20"));
var trc10_1 = __importDefault(require("../data/trc10"));
var trc20_1 = __importDefault(require("../data/trc20"));
var bep20_1 = __importDefault(require("../data/bep20"));
var polygon_erc20_1 = __importDefault(require("../data/polygon-erc20"));
var asa_1 = __importDefault(require("../data/asa"));
var esdt_1 = __importDefault(require("../data/esdt"));
//import spltokens from "../data/spl";
var emptyArray = [];
var tokensArray = [];
var tokensArrayWithDelisted = [];
var tokensByCryptoCurrency = {};
var tokensByCryptoCurrencyWithDelisted = {};
var tokensById = {};
var tokensByTicker = {};
var tokensByAddress = {};
var tokensByCurrencyAddress = {};
addTokens(erc20_1["default"].map(convertERC20));
addTokens(polygon_erc20_1["default"].map(convertERC20));
addTokens(trc10_1["default"].map(convertTRONTokens("trc10")));
addTokens(trc20_1["default"].map(convertTRONTokens("trc20")));
addTokens(bep20_1["default"].map(convertBEP20));
addTokens(asa_1["default"].map(convertAlgorandASATokens));
addTokens(esdt_1["default"].map(convertElrondESDTTokens));
var defaultTokenListOptions = {
    withDelisted: false
};
/**
 *
 */
function listTokens(options) {
    var withDelisted = __assign(__assign({}, defaultTokenListOptions), options).withDelisted;
    return withDelisted ? tokensArrayWithDelisted : tokensArray;
}
exports.listTokens = listTokens;
/**
 *
 */
function listTokensForCryptoCurrency(currency, options) {
    var withDelisted = __assign(__assign({}, defaultTokenListOptions), options).withDelisted;
    if (withDelisted) {
        return tokensByCryptoCurrencyWithDelisted[currency.id] || emptyArray;
    }
    return tokensByCryptoCurrency[currency.id] || emptyArray;
}
exports.listTokensForCryptoCurrency = listTokensForCryptoCurrency;
/**
 *
 */
function listTokenTypesForCryptoCurrency(currency) {
    return listTokensForCryptoCurrency(currency).reduce(function (acc, cur) {
        var tokenType = cur.tokenType;
        if (acc.indexOf(tokenType) < 0) {
            return __spreadArray(__spreadArray([], __read(acc), false), [tokenType], false);
        }
        return acc;
    }, []);
}
exports.listTokenTypesForCryptoCurrency = listTokenTypesForCryptoCurrency;
/**
 *
 */
function findTokenByTicker(ticker) {
    return tokensByTicker[ticker];
}
exports.findTokenByTicker = findTokenByTicker;
/**
 *
 */
function findTokenById(id) {
    return tokensById[id];
}
exports.findTokenById = findTokenById;
var deprecatedDisplayed = false;
function findTokenByAddress(address) {
    if (!deprecatedDisplayed) {
        deprecatedDisplayed = true;
        console.warn("findTokenByAddress is deprecated. use findTokenByAddressInCurrency");
    }
    return tokensByAddress[address.toLowerCase()];
}
exports.findTokenByAddress = findTokenByAddress;
function findTokenByAddressInCurrency(address, currencyId) {
    return tokensByCurrencyAddress[currencyId + ":" + address.toLowerCase()];
}
exports.findTokenByAddressInCurrency = findTokenByAddressInCurrency;
/**
 *
 */
var hasTokenId = function (id) { return id in tokensById; };
exports.hasTokenId = hasTokenId;
/**
 *
 */
function getTokenById(id) {
    var currency = findTokenById(id);
    if (!currency) {
        throw new Error("token with id \"".concat(id, "\" not found"));
    }
    return currency;
}
exports.getTokenById = getTokenById;
/**
 * if a given token account is a token that can be used in compound, give the associated compound token (cToken)
 * @param {*} token
 */
function findCompoundToken(token) {
    // TODO can be optimized by generating a direct map
    return listTokensForCryptoCurrency(token.parentCurrency, {
        withDelisted: true
    }).find(function (t) { return t.compoundFor === token.id; });
}
exports.findCompoundToken = findCompoundToken;
function comparePriority(a, b) {
    return Number(!!b.disableCountervalue) - Number(!!a.disableCountervalue);
}
function addTokens(list) {
    list.forEach(function (token) {
        if (!token.delisted)
            tokensArray.push(token);
        tokensArrayWithDelisted.push(token);
        tokensById[token.id] = token;
        if (!tokensByTicker[token.ticker] ||
            comparePriority(token, tokensByTicker[token.ticker]) > 0) {
            tokensByTicker[token.ticker] = token;
        }
        var lowCaseContract = token.contractAddress.toLowerCase();
        tokensByAddress[lowCaseContract] = token;
        var parentCurrency = token.parentCurrency;
        tokensByCurrencyAddress[parentCurrency.id + ":" + lowCaseContract] = token;
        if (!(parentCurrency.id in tokensByCryptoCurrency)) {
            tokensByCryptoCurrency[parentCurrency.id] = [];
        }
        if (!(parentCurrency.id in tokensByCryptoCurrencyWithDelisted)) {
            tokensByCryptoCurrencyWithDelisted[parentCurrency.id] = [];
        }
        if (!token.delisted)
            tokensByCryptoCurrency[parentCurrency.id].push(token);
        tokensByCryptoCurrencyWithDelisted[parentCurrency.id].push(token);
    });
}
function convertERC20(_a) {
    var _b = __read(_a, 11), parentCurrencyId = _b[0], token = _b[1], ticker = _b[2], magnitude = _b[3], name = _b[4], ledgerSignature = _b[5], contractAddress = _b[6], disableCountervalue = _b[7], delisted = _b[8], countervalueTicker = _b[9], compoundFor = _b[10];
    var parentCurrency = (0, currencies_1.getCryptoCurrencyById)(parentCurrencyId);
    return {
        type: "TokenCurrency",
        id: parentCurrencyId + "/erc20/" + token,
        ledgerSignature: ledgerSignature,
        contractAddress: contractAddress,
        parentCurrency: parentCurrency,
        tokenType: "erc20",
        name: name,
        ticker: ticker,
        delisted: delisted,
        disableCountervalue: !!parentCurrency.isTestnetFor || !!disableCountervalue,
        countervalueTicker: countervalueTicker,
        compoundFor: compoundFor
            ? parentCurrencyId + "/erc20/" + compoundFor
            : undefined,
        units: [
            {
                name: name,
                code: ticker,
                magnitude: magnitude
            },
        ]
    };
}
function convertBEP20(_a) {
    var _b = __read(_a, 10), parentCurrencyId = _b[0], token = _b[1], ticker = _b[2], magnitude = _b[3], name = _b[4], ledgerSignature = _b[5], contractAddress = _b[6], disableCountervalue = _b[7], delisted = _b[8], countervalueTicker = _b[9];
    var parentCurrency = (0, currencies_1.getCryptoCurrencyById)(parentCurrencyId);
    return {
        type: "TokenCurrency",
        id: parentCurrencyId + "/bep20/" + token,
        ledgerSignature: ledgerSignature,
        contractAddress: contractAddress,
        parentCurrency: parentCurrency,
        tokenType: "bep20",
        name: name,
        ticker: ticker,
        delisted: delisted,
        disableCountervalue: !!parentCurrency.isTestnetFor || !!disableCountervalue,
        countervalueTicker: countervalueTicker,
        units: [
            {
                name: name,
                code: ticker,
                magnitude: magnitude
            },
        ]
    };
}
function convertAlgorandASATokens(_a) {
    var _b = __read(_a, 6), id = _b[0], abbr = _b[1], name = _b[2], contractAddress = _b[3], precision = _b[4], enableCountervalues = _b[5];
    return {
        type: "TokenCurrency",
        id: "algorand/asa/".concat(id),
        contractAddress: contractAddress,
        parentCurrency: (0, currencies_1.getCryptoCurrencyById)("algorand"),
        tokenType: "asa",
        name: name,
        ticker: abbr,
        disableCountervalue: !enableCountervalues,
        units: [
            {
                name: name,
                code: abbr,
                magnitude: precision
            },
        ]
    };
}
function convertTRONTokens(type) {
    return function (_a) {
        var _b = __read(_a, 8), id = _b[0], abbr = _b[1], name = _b[2], contractAddress = _b[3], precision = _b[4], delisted = _b[5], ledgerSignature = _b[6], enableCountervalues = _b[7];
        return ({
            type: "TokenCurrency",
            id: "tron/".concat(type, "/").concat(id),
            contractAddress: contractAddress,
            parentCurrency: (0, currencies_1.getCryptoCurrencyById)("tron"),
            tokenType: type,
            name: name,
            ticker: abbr,
            delisted: delisted,
            disableCountervalue: !enableCountervalues,
            ledgerSignature: ledgerSignature,
            units: [
                {
                    name: name,
                    code: abbr,
                    magnitude: precision
                },
            ]
        });
    };
}
function convertElrondESDTTokens(_a) {
    var _b = __read(_a, 5), ticker = _b[0], identifier = _b[1], decimals = _b[2], signature = _b[3], name = _b[4];
    var ELROND_ESDT_CONTRACT = "erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u";
    return {
        type: "TokenCurrency",
        id: "elrond/esdt/".concat(identifier),
        contractAddress: ELROND_ESDT_CONTRACT,
        ledgerSignature: signature,
        parentCurrency: (0, currencies_1.getCryptoCurrencyById)("elrond"),
        tokenType: "esdt",
        name: name,
        ticker: ticker,
        units: [
            {
                name: name,
                code: ticker,
                magnitude: decimals
            },
        ]
    };
}
/* eslint-disable-next-line @typescript-eslint/no-unused-vars */
function convertSplTokens(_a) {
    var _b = __read(_a, 6), chainId = _b[0], name = _b[1], symbol = _b[2], address = _b[3], decimals = _b[4], enableCountervalues = _b[5];
    var chainIdToCurrencyId = {
        101: "solana",
        102: "solana_testnet",
        103: "solana_devnet"
    };
    var currencyId = chainIdToCurrencyId[chainId];
    return {
        contractAddress: address,
        parentCurrency: (0, currencies_1.getCryptoCurrencyById)(currencyId),
        id: "solana/spl/".concat(address),
        name: name,
        tokenType: "spl",
        ticker: symbol,
        type: "TokenCurrency",
        disableCountervalue: !enableCountervalues,
        units: [
            {
                name: name,
                code: symbol,
                magnitude: decimals
            },
        ]
    };
}
//# sourceMappingURL=tokens.js.map