"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var utils_1 = require("./utils");
var ledger_1 = __importDefault(require("./services/ledger"));
var errors_1 = require("./errors");
var starkQuantizationTypeMap = {
    eth: 1,
    erc20: 2,
    erc721: 3,
    erc20mintable: 4,
    erc721mintable: 5
};
function splitPath(path) {
    var result = [];
    var components = path.split("/");
    components.forEach(function (element) {
        var number = parseInt(element, 10);
        if (isNaN(number)) {
            return; // FIXME shouldn't it throws instead?
        }
        if (element.length > 1 && element[element.length - 1] === "'") {
            number += 0x80000000;
        }
        result.push(number);
    });
    return result;
}
function hexBuffer(str) {
    return Buffer.from(str.startsWith("0x") ? str.slice(2) : str, "hex");
}
function maybeHexBuffer(str) {
    if (!str)
        return null;
    return hexBuffer(str);
}
var remapTransactionRelatedErrors = function (e) {
    if (e && e.statusCode === 0x6a80) {
        return new errors_1.EthAppPleaseEnableContractData("Please enable Blind signing or Contract data in the Ethereum app Settings");
    }
    return e;
};
/**
 * Ethereum API
 *
 * @example
 * import Eth from "@ledgerhq/hw-app-eth";
 * const eth = new Eth(transport)
 */
var Eth = /** @class */ (function () {
    function Eth(transport, scrambleKey, loadConfig) {
        if (scrambleKey === void 0) { scrambleKey = "w0w"; }
        if (loadConfig === void 0) { loadConfig = {}; }
        this.transport = transport;
        this.loadConfig = loadConfig;
        transport.decorateAppAPIMethods(this, [
            "getAddress",
            "provideERC20TokenInformation",
            "signTransaction",
            "signPersonalMessage",
            "getAppConfiguration",
            "signEIP712HashedMessage",
            "starkGetPublicKey",
            "starkSignOrder",
            "starkSignOrder_v2",
            "starkSignTransfer",
            "starkSignTransfer_v2",
            "starkProvideQuantum",
            "starkProvideQuantum_v2",
            "starkUnsafeSign",
            "eth2GetPublicKey",
            "eth2SetWithdrawalIndex",
            "setExternalPlugin",
            "setPlugin",
            "getEIP1024PublicEncryptionKey",
            "getEIP1024SharedSecret",
        ], scrambleKey);
    }
    Eth.prototype.setLoadConfig = function (loadConfig) {
        this.loadConfig = loadConfig;
    };
    /**
     * get Ethereum address for a given BIP 32 path.
     * @param path a path in BIP 32 format
     * @option boolDisplay optionally enable or not the display
     * @option boolChaincode optionally enable or not the chaincode request
     * @return an object with a publicKey, address and (optionally) chainCode
     * @example
     * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
     */
    Eth.prototype.getAddress = function (path, boolDisplay, boolChaincode) {
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4);
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        return this.transport
            .send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer)
            .then(function (response) {
            var publicKeyLength = response[0];
            var addressLength = response[1 + publicKeyLength];
            return {
                publicKey: response.slice(1, 1 + publicKeyLength).toString("hex"),
                address: "0x" +
                    response
                        .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)
                        .toString("ascii"),
                chainCode: boolChaincode
                    ? response
                        .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)
                        .toString("hex")
                    : undefined
            };
        });
    };
    /**
     * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
     *
     * @param path: the BIP32 path to sign the transaction on
     * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
     * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
     * @example
     import ledgerService from "@ledgerhq/hw-app-eth/lib/services/ledger"
     const tx = "e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080"; // raw tx to sign
     const resolution = await ledgerService.resolveTransaction(tx);
     const result = eth.signTransaction("44'/60'/0'/0/0", tx, resolution);
     console.log(result);
     */
    Eth.prototype.signTransaction = function (path, rawTxHex, resolution) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, plugin, e_1_1, _c, _d, _e, payload, signature, e_2_1, _f, _g, nft, e_3_1, _h, _j, data, e_4_1, rawTx, _k, vrsOffset, txType, chainId, chainIdTruncated, paths, response, offset, _loop_1, this_1, response_byte, v, oneByteChainId, ecc_parity, r, s;
            var e_1, _l, e_2, _m, e_3, _o, e_4, _p;
            return __generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        if (!(resolution === undefined)) return [3 /*break*/, 2];
                        console.warn("hw-app-eth: signTransaction(path, rawTxHex, resolution): " +
                            "please provide the 'resolution' parameter. " +
                            "See https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-eth/README.md " +
                            "â€“ the previous signature is deprecated and providing the 3rd 'resolution' parameter explicitly will become mandatory so you have the control on the resolution and the fallback mecanism (e.g. fallback to blind signing or not)." +
                            "// Possible solution:\n" +
                            " + import ledgerService from '@ledgerhq/hw-app-eth/lib/services/ledger';\n" +
                            " + const resolution = await ledgerService.resolveTransaction(rawTxHex);");
                        return [4 /*yield*/, ledger_1["default"]
                                .resolveTransaction(rawTxHex, this.loadConfig, {
                                externalPlugins: true,
                                erc20: true
                            })["catch"](function (e) {
                                console.warn("an error occurred in resolveTransaction => fallback to blind signing: " +
                                    String(e));
                                return null;
                            })];
                    case 1:
                        resolution = _q.sent();
                        _q.label = 2;
                    case 2:
                        if (!resolution) return [3 /*break*/, 31];
                        _q.label = 3;
                    case 3:
                        _q.trys.push([3, 8, 9, 10]);
                        _a = __values(resolution.plugin), _b = _a.next();
                        _q.label = 4;
                    case 4:
                        if (!!_b.done) return [3 /*break*/, 7];
                        plugin = _b.value;
                        return [4 /*yield*/, setPlugin(this.transport, plugin)];
                    case 5:
                        _q.sent();
                        _q.label = 6;
                    case 6:
                        _b = _a.next();
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_1_1 = _q.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_b && !_b.done && (_l = _a["return"])) _l.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 10:
                        _q.trys.push([10, 15, 16, 17]);
                        _c = __values(resolution.externalPlugin), _d = _c.next();
                        _q.label = 11;
                    case 11:
                        if (!!_d.done) return [3 /*break*/, 14];
                        _e = _d.value, payload = _e.payload, signature = _e.signature;
                        return [4 /*yield*/, setExternalPlugin(this.transport, payload, signature)];
                    case 12:
                        _q.sent();
                        _q.label = 13;
                    case 13:
                        _d = _c.next();
                        return [3 /*break*/, 11];
                    case 14: return [3 /*break*/, 17];
                    case 15:
                        e_2_1 = _q.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 17];
                    case 16:
                        try {
                            if (_d && !_d.done && (_m = _c["return"])) _m.call(_c);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 17:
                        _q.trys.push([17, 22, 23, 24]);
                        _f = __values(resolution.nfts), _g = _f.next();
                        _q.label = 18;
                    case 18:
                        if (!!_g.done) return [3 /*break*/, 21];
                        nft = _g.value;
                        return [4 /*yield*/, provideNFTInformation(this.transport, Buffer.from(nft, "hex"))];
                    case 19:
                        _q.sent();
                        _q.label = 20;
                    case 20:
                        _g = _f.next();
                        return [3 /*break*/, 18];
                    case 21: return [3 /*break*/, 24];
                    case 22:
                        e_3_1 = _q.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 24];
                    case 23:
                        try {
                            if (_g && !_g.done && (_o = _f["return"])) _o.call(_f);
                        }
                        finally { if (e_3) throw e_3.error; }
                        return [7 /*endfinally*/];
                    case 24:
                        _q.trys.push([24, 29, 30, 31]);
                        _h = __values(resolution.erc20Tokens), _j = _h.next();
                        _q.label = 25;
                    case 25:
                        if (!!_j.done) return [3 /*break*/, 28];
                        data = _j.value;
                        return [4 /*yield*/, provideERC20TokenInformation(this.transport, Buffer.from(data, "hex"))];
                    case 26:
                        _q.sent();
                        _q.label = 27;
                    case 27:
                        _j = _h.next();
                        return [3 /*break*/, 25];
                    case 28: return [3 /*break*/, 31];
                    case 29:
                        e_4_1 = _q.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 31];
                    case 30:
                        try {
                            if (_j && !_j.done && (_p = _h["return"])) _p.call(_h);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 31:
                        rawTx = Buffer.from(rawTxHex, "hex");
                        _k = (0, utils_1.decodeTxInfo)(rawTx), vrsOffset = _k.vrsOffset, txType = _k.txType, chainId = _k.chainId, chainIdTruncated = _k.chainIdTruncated;
                        paths = splitPath(path);
                        offset = 0;
                        _loop_1 = function () {
                            var first, maxChunkSize, chunkSize, buffer;
                            return __generator(this, function (_r) {
                                switch (_r.label) {
                                    case 0:
                                        first = offset === 0;
                                        maxChunkSize = first ? 150 - 1 - paths.length * 4 : 150;
                                        chunkSize = offset + maxChunkSize > rawTx.length
                                            ? rawTx.length - offset
                                            : maxChunkSize;
                                        if (vrsOffset != 0 && offset + chunkSize >= vrsOffset) {
                                            // Make sure that the chunk doesn't end right on the EIP 155 marker if set
                                            chunkSize = rawTx.length - offset;
                                        }
                                        buffer = Buffer.alloc(first ? 1 + paths.length * 4 + chunkSize : chunkSize);
                                        if (first) {
                                            buffer[0] = paths.length;
                                            paths.forEach(function (element, index) {
                                                buffer.writeUInt32BE(element, 1 + 4 * index);
                                            });
                                            rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);
                                        }
                                        else {
                                            rawTx.copy(buffer, 0, offset, offset + chunkSize);
                                        }
                                        return [4 /*yield*/, this_1.transport
                                                .send(0xe0, 0x04, first ? 0x00 : 0x80, 0x00, buffer)["catch"](function (e) {
                                                throw remapTransactionRelatedErrors(e);
                                            })];
                                    case 1:
                                        response = _r.sent();
                                        offset += chunkSize;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _q.label = 32;
                    case 32:
                        if (!(offset !== rawTx.length)) return [3 /*break*/, 34];
                        return [5 /*yield**/, _loop_1()];
                    case 33:
                        _q.sent();
                        return [3 /*break*/, 32];
                    case 34:
                        response_byte = response[0];
                        v = "";
                        if (chainId.times(2).plus(35).plus(1).isGreaterThan(255)) {
                            oneByteChainId = (chainIdTruncated * 2 + 35) % 256;
                            ecc_parity = Math.abs(response_byte - oneByteChainId);
                            if (txType != null) {
                                // For EIP2930 and EIP1559 tx, v is simply the parity.
                                v = ecc_parity % 2 == 1 ? "00" : "01";
                            }
                            else {
                                // Legacy type transaction with a big chain ID
                                v = chainId.times(2).plus(35).plus(ecc_parity).toString(16);
                            }
                        }
                        else {
                            v = response_byte.toString(16);
                        }
                        // Make sure v has is prefixed with a 0 if its length is odd ("1" -> "01").
                        if (v.length % 2 == 1) {
                            v = "0" + v;
                        }
                        r = response.slice(1, 1 + 32).toString("hex");
                        s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
                        return [2 /*return*/, { v: v, r: r, s: s }];
                }
            });
        });
    };
    /**
     */
    Eth.prototype.getAppConfiguration = function () {
        return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(function (response) {
            return {
                arbitraryDataEnabled: response[0] & 0x01,
                erc20ProvisioningNecessary: response[0] & 0x02,
                starkEnabled: response[0] & 0x04,
                starkv2Supported: response[0] & 0x08,
                version: "" + response[1] + "." + response[2] + "." + response[3]
            };
        });
    };
    /**
    * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.
    * @example
    eth.signPersonalMessage("44'/60'/0'/0/0", Buffer.from("test").toString("hex")).then(result => {
    var v = result['v'] - 27;
    v = v.toString(16);
    if (v.length < 2) {
      v = "0" + v;
    }
    console.log("Signature 0x" + result['r'] + result['s'] + v);
    })
     */
    Eth.prototype.signPersonalMessage = function (path, messageHex) {
        return __awaiter(this, void 0, void 0, function () {
            var paths, offset, message, response, _loop_2, this_2, v, r, s;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        paths = splitPath(path);
                        offset = 0;
                        message = Buffer.from(messageHex, "hex");
                        _loop_2 = function () {
                            var maxChunkSize, chunkSize, buffer;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;
                                        chunkSize = offset + maxChunkSize > message.length
                                            ? message.length - offset
                                            : maxChunkSize;
                                        buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);
                                        if (offset === 0) {
                                            buffer[0] = paths.length;
                                            paths.forEach(function (element, index) {
                                                buffer.writeUInt32BE(element, 1 + 4 * index);
                                            });
                                            buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);
                                            message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);
                                        }
                                        else {
                                            message.copy(buffer, 0, offset, offset + chunkSize);
                                        }
                                        return [4 /*yield*/, this_2.transport.send(0xe0, 0x08, offset === 0 ? 0x00 : 0x80, 0x00, buffer)];
                                    case 1:
                                        response = _b.sent();
                                        offset += chunkSize;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_2 = this;
                        _a.label = 1;
                    case 1:
                        if (!(offset !== message.length)) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_2()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        v = response[0];
                        r = response.slice(1, 1 + 32).toString("hex");
                        s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
                        return [2 /*return*/, { v: v, r: r, s: s }];
                }
            });
        });
    };
    /**
    * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)
    * @example
    eth.signEIP712HashedMessage("44'/60'/0'/0/0", Buffer.from("0101010101010101010101010101010101010101010101010101010101010101").toString("hex"), Buffer.from("0202020202020202020202020202020202020202020202020202020202020202").toString("hex")).then(result => {
    var v = result['v'] - 27;
    v = v.toString(16);
    if (v.length < 2) {
      v = "0" + v;
    }
    console.log("Signature 0x" + result['r'] + result['s'] + v);
    })
     */
    Eth.prototype.signEIP712HashedMessage = function (path, domainSeparatorHex, hashStructMessageHex) {
        var domainSeparator = hexBuffer(domainSeparatorHex);
        var hashStruct = hexBuffer(hashStructMessageHex);
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        domainSeparator.copy(buffer, offset);
        offset += 32;
        hashStruct.copy(buffer, offset);
        return this.transport
            .send(0xe0, 0x0c, 0x00, 0x00, buffer)
            .then(function (response) {
            var v = response[0];
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                v: v,
                r: r,
                s: s
            };
        });
    };
    /**
     * get Stark public key for a given BIP 32 path.
     * @param path a path in BIP 32 format
     * @option boolDisplay optionally enable or not the display
     * @return the Stark public key
     */
    Eth.prototype.starkGetPublicKey = function (path, boolDisplay) {
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4);
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        return this.transport
            .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)
            .then(function (response) {
            return response.slice(0, response.length - 2);
        });
    };
    /**
     * sign a Stark order
     * @param path a path in BIP 32 format
     * @option sourceTokenAddress contract address of the source token (not present for ETH)
     * @param sourceQuantization quantization used for the source token
     * @option destinationTokenAddress contract address of the destination token (not present for ETH)
     * @param destinationQuantization quantization used for the destination token
     * @param sourceVault ID of the source vault
     * @param destinationVault ID of the destination vault
     * @param amountSell amount to sell
     * @param amountBuy amount to buy
     * @param nonce transaction nonce
     * @param timestamp transaction validity timestamp
     * @return the signature
     */
    Eth.prototype.starkSignOrder = function (path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {
        var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);
        var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        if (sourceTokenAddressHex) {
            sourceTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        Buffer.from(sourceQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        offset += 32;
        if (destinationTokenAddressHex) {
            destinationTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        Buffer.from(destinationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        offset += 32;
        buffer.writeUInt32BE(sourceVault, offset);
        offset += 4;
        buffer.writeUInt32BE(destinationVault, offset);
        offset += 4;
        Buffer.from(amountSell.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        Buffer.from(amountBuy.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        buffer.writeUInt32BE(nonce, offset);
        offset += 4;
        buffer.writeUInt32BE(timestamp, offset);
        return this.transport
            .send(0xf0, 0x04, 0x01, 0x00, buffer)
            .then(function (response) {
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                r: r,
                s: s
            };
        });
    };
    /**
     * sign a Stark order using the Starkex V2 protocol
     * @param path a path in BIP 32 format
     * @option sourceTokenAddress contract address of the source token (not present for ETH)
     * @param sourceQuantizationType quantization type used for the source token
     * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)
     * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token
     * @option destinationTokenAddress contract address of the destination token (not present for ETH)
     * @param destinationQuantizationType quantization type used for the destination token
     * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)
     * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token
     * @param sourceVault ID of the source vault
     * @param destinationVault ID of the destination vault
     * @param amountSell amount to sell
     * @param amountBuy amount to buy
     * @param nonce transaction nonce
     * @param timestamp transaction validity timestamp
     * @return the signature
     */
    Eth.prototype.starkSignOrder_v2 = function (path, sourceTokenAddress, sourceQuantizationType, sourceQuantization, sourceMintableBlobOrTokenId, destinationTokenAddress, destinationQuantizationType, destinationQuantization, destinationMintableBlobOrTokenId, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {
        var sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);
        var destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);
        if (!(sourceQuantizationType in starkQuantizationTypeMap)) {
            throw new Error("eth.starkSignOrderv2 invalid source quantization type=" +
                sourceQuantizationType);
        }
        if (!(destinationQuantizationType in starkQuantizationTypeMap)) {
            throw new Error("eth.starkSignOrderv2 invalid destination quantization type=" +
                destinationQuantizationType);
        }
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 +
            paths.length * 4 +
            1 +
            20 +
            32 +
            32 +
            1 +
            20 +
            32 +
            32 +
            4 +
            4 +
            8 +
            8 +
            4 +
            4, 0);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];
        offset++;
        if (sourceTokenAddressHex) {
            sourceTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        if (sourceQuantization) {
            Buffer.from(sourceQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        if (sourceMintableBlobOrTokenId) {
            Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];
        offset++;
        if (destinationTokenAddressHex) {
            destinationTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        if (destinationQuantization) {
            Buffer.from(destinationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        if (destinationMintableBlobOrTokenId) {
            Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        buffer.writeUInt32BE(sourceVault, offset);
        offset += 4;
        buffer.writeUInt32BE(destinationVault, offset);
        offset += 4;
        Buffer.from(amountSell.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        Buffer.from(amountBuy.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        buffer.writeUInt32BE(nonce, offset);
        offset += 4;
        buffer.writeUInt32BE(timestamp, offset);
        return this.transport
            .send(0xf0, 0x04, 0x03, 0x00, buffer)
            .then(function (response) {
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                r: r,
                s: s
            };
        });
    };
    /**
     * sign a Stark transfer
     * @param path a path in BIP 32 format
     * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)
     * @param transferQuantization quantization used for the token to be transferred
     * @param targetPublicKey target Stark public key
     * @param sourceVault ID of the source vault
     * @param destinationVault ID of the destination vault
     * @param amountTransfer amount to transfer
     * @param nonce transaction nonce
     * @param timestamp transaction validity timestamp
     * @return the signature
     */
    Eth.prototype.starkSignTransfer = function (path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {
        var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);
        var targetPublicKeyHex = hexBuffer(targetPublicKey);
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        if (transferTokenAddressHex) {
            transferTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        Buffer.from(transferQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        offset += 32;
        targetPublicKeyHex.copy(buffer, offset);
        offset += 32;
        buffer.writeUInt32BE(sourceVault, offset);
        offset += 4;
        buffer.writeUInt32BE(destinationVault, offset);
        offset += 4;
        Buffer.from(amountTransfer.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        buffer.writeUInt32BE(nonce, offset);
        offset += 4;
        buffer.writeUInt32BE(timestamp, offset);
        return this.transport
            .send(0xf0, 0x04, 0x02, 0x00, buffer)
            .then(function (response) {
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                r: r,
                s: s
            };
        });
    };
    /**
     * sign a Stark transfer or conditional transfer using the Starkex V2 protocol
     * @param path a path in BIP 32 format
     * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)
     * @param transferQuantizationType quantization type used for the token to be transferred
     * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)
     * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred
     * @param targetPublicKey target Stark public key
     * @param sourceVault ID of the source vault
     * @param destinationVault ID of the destination vault
     * @param amountTransfer amount to transfer
     * @param nonce transaction nonce
     * @param timestamp transaction validity timestamp
     * @option conditionalTransferAddress onchain address of the condition for a conditional transfer
     * @option conditionalTransferFact fact associated to the condition for a conditional transfer
     * @return the signature
     */
    Eth.prototype.starkSignTransfer_v2 = function (path, transferTokenAddress, transferQuantizationType, transferQuantization, transferMintableBlobOrTokenId, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp, conditionalTransferAddress, conditionalTransferFact) {
        var transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);
        var targetPublicKeyHex = hexBuffer(targetPublicKey);
        var conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);
        if (!(transferQuantizationType in starkQuantizationTypeMap)) {
            throw new Error("eth.starkSignTransferv2 invalid quantization type=" +
                transferQuantizationType);
        }
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 +
            paths.length * 4 +
            1 +
            20 +
            32 +
            32 +
            32 +
            4 +
            4 +
            8 +
            4 +
            4 +
            (conditionalTransferAddressHex ? 32 + 20 : 0), 0);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];
        offset++;
        if (transferTokenAddressHex) {
            transferTokenAddressHex.copy(buffer, offset);
        }
        offset += 20;
        if (transferQuantization) {
            Buffer.from(transferQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        if (transferMintableBlobOrTokenId) {
            Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        targetPublicKeyHex.copy(buffer, offset);
        offset += 32;
        buffer.writeUInt32BE(sourceVault, offset);
        offset += 4;
        buffer.writeUInt32BE(destinationVault, offset);
        offset += 4;
        Buffer.from(amountTransfer.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);
        offset += 8;
        buffer.writeUInt32BE(nonce, offset);
        offset += 4;
        buffer.writeUInt32BE(timestamp, offset);
        if (conditionalTransferAddressHex && conditionalTransferFact) {
            offset += 4;
            Buffer.from(conditionalTransferFact.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
            offset += 32;
            conditionalTransferAddressHex.copy(buffer, offset);
        }
        return this.transport
            .send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer)
            .then(function (response) {
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                r: r,
                s: s
            };
        });
    };
    /**
     * provide quantization information before singing a deposit or withdrawal Stark powered contract call
     *
     * It shall be run following a provideERC20TokenInformation call for the given contract
     *
     * @param operationContract contract address of the token to be transferred (not present for ETH)
     * @param operationQuantization quantization used for the token to be transferred
     */
    Eth.prototype.starkProvideQuantum = function (operationContract, operationQuantization) {
        var operationContractHex = maybeHexBuffer(operationContract);
        var buffer = Buffer.alloc(20 + 32, 0);
        if (operationContractHex) {
            operationContractHex.copy(buffer, 0);
        }
        Buffer.from(operationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, 20);
        return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {
            if (e && e.statusCode === 0x6d00) {
                // this case happen for ETH application versions not supporting Stark extensions
                return false;
            }
            throw e;
        });
    };
    /**
     * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol
     *
     * It shall be run following a provideERC20TokenInformation call for the given contract
     *
     * @param operationContract contract address of the token to be transferred (not present for ETH)
     * @param operationQuantizationType quantization type of the token to be transferred
     * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)
     * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred
     */
    Eth.prototype.starkProvideQuantum_v2 = function (operationContract, operationQuantizationType, operationQuantization, operationMintableBlobOrTokenId) {
        var operationContractHex = maybeHexBuffer(operationContract);
        if (!(operationQuantizationType in starkQuantizationTypeMap)) {
            throw new Error("eth.starkProvideQuantumV2 invalid quantization type=" +
                operationQuantizationType);
        }
        var buffer = Buffer.alloc(20 + 32 + 32, 0);
        var offset = 0;
        if (operationContractHex) {
            operationContractHex.copy(buffer, offset);
        }
        offset += 20;
        if (operationQuantization) {
            Buffer.from(operationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        offset += 32;
        if (operationMintableBlobOrTokenId) {
            Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);
        }
        return this.transport
            .send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer)
            .then(function () { return true; }, function (e) {
            if (e && e.statusCode === 0x6d00) {
                // this case happen for ETH application versions not supporting Stark extensions
                return false;
            }
            throw e;
        });
    };
    /**
     * sign the given hash over the Stark curve
     * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.
     * @param path a path in BIP 32 format
     * @param hash hexadecimal hash to sign
     * @return the signature
     */
    Eth.prototype.starkUnsafeSign = function (path, hash) {
        var hashHex = hexBuffer(hash);
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4 + 32);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        hashHex.copy(buffer, offset);
        return this.transport
            .send(0xf0, 0x0a, 0x00, 0x00, buffer)
            .then(function (response) {
            var r = response.slice(1, 1 + 32).toString("hex");
            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
            return {
                r: r,
                s: s
            };
        });
    };
    /**
     * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.
     * @param path a path in BIP 32 format
     * @option boolDisplay optionally enable or not the display
     * @return an object with a publicKey
     * @example
     * eth.eth2GetPublicKey("12381/3600/0/0").then(o => o.publicKey)
     */
    Eth.prototype.eth2GetPublicKey = function (path, boolDisplay) {
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4);
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        return this.transport
            .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)
            .then(function (response) {
            return {
                publicKey: response.slice(0, -2).toString("hex")
            };
        });
    };
    /**
     * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature
     *
     * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0
     *
     * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0
     * @return True if the method was executed successfully
     */
    Eth.prototype.eth2SetWithdrawalIndex = function (withdrawalIndex) {
        var buffer = Buffer.alloc(4, 0);
        buffer.writeUInt32BE(withdrawalIndex, 0);
        return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {
            if (e && e.statusCode === 0x6d00) {
                // this case happen for ETH application versions not supporting ETH 2
                return false;
            }
            throw e;
        });
    };
    /**
     * get a public encryption key on Curve25519 according to EIP 1024
     * @param path a path in BIP 32 format
     * @option boolDisplay optionally enable or not the display
     * @return an object with a publicKey
     * @example
     * eth.getEIP1024PublicEncryptionKey("44'/60'/0'/0/0").then(o => o.publicKey)
     */
    Eth.prototype.getEIP1024PublicEncryptionKey = function (path, boolDisplay) {
        var paths = splitPath(path);
        var buffer = Buffer.alloc(1 + paths.length * 4);
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        return this.transport
            .send(0xe0, 0x18, boolDisplay ? 0x01 : 0x00, 0x00, buffer)
            .then(function (response) {
            return {
                publicKey: response.slice(0, -2).toString("hex")
            };
        });
    };
    /**
     * get a shared secret on Curve25519 according to EIP 1024
     * @param path a path in BIP 32 format
     * @param remotePublicKeyHex remote Curve25519 public key
     * @option boolDisplay optionally enable or not the display
     * @return an object with a shared secret
     * @example
     * eth.getEIP1024SharedSecret("44'/60'/0'/0/0", "87020e80af6e07a6e4697f091eacadb9e7e6629cb7e5a8a371689a3ed53b3d64").then(o => o.sharedSecret)
     */
    Eth.prototype.getEIP1024SharedSecret = function (path, remotePublicKeyHex, boolDisplay) {
        var paths = splitPath(path);
        var remotePublicKey = hexBuffer(remotePublicKeyHex);
        var buffer = Buffer.alloc(1 + paths.length * 4 + 32);
        var offset = 0;
        buffer[0] = paths.length;
        paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        offset = 1 + 4 * paths.length;
        remotePublicKey.copy(buffer, offset);
        return this.transport
            .send(0xe0, 0x18, boolDisplay ? 0x01 : 0x00, 0x01, buffer)
            .then(function (response) {
            return {
                sharedSecret: response.slice(0, -2).toString("hex")
            };
        });
    };
    Eth.prototype.provideERC20TokenInformation = function (_a) {
        var data = _a.data;
        console.warn("hw-app-eth: eth.provideERC20TokenInformation is deprecated. signTransaction solves this for you when providing it in `resolution`.");
        return provideERC20TokenInformation(this.transport, data);
    };
    Eth.prototype.setExternalPlugin = function (pluginName, contractAddress, selector) {
        console.warn("hw-app-eth: eth.setExternalPlugin is deprecated. signTransaction solves this for you when providing it in `resolution`.");
        return setExternalPlugin(this.transport, pluginName, selector);
    };
    Eth.prototype.setPlugin = function (data) {
        console.warn("hw-app-eth: eth.setPlugin is deprecated. signTransaction solves this for you when providing it in `resolution`.");
        return setPlugin(this.transport, data);
    };
    return Eth;
}());
exports["default"] = Eth;
// internal helpers
function provideERC20TokenInformation(transport, data) {
    return transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(function () { return true; }, function (e) {
        if (e && e.statusCode === 0x6d00) {
            // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.
            // we return a flag to know if the call was effective or not
            return false;
        }
        throw e;
    });
}
function provideNFTInformation(transport, data) {
    return transport.send(0xe0, 0x14, 0x00, 0x00, data).then(function () { return true; }, function (e) {
        if (e && e.statusCode === 0x6d00) {
            // older version of ETH app => error because we don't allow blind sign when NFT is explicitly requested to be resolved.
            throw new errors_1.EthAppNftNotSupported();
        }
        throw e;
    });
}
function setExternalPlugin(transport, payload, signature) {
    var payloadBuffer = Buffer.from(payload, "hex");
    var signatureBuffer = Buffer.from(signature, "hex");
    var buffer = Buffer.concat([payloadBuffer, signatureBuffer]);
    return transport.send(0xe0, 0x12, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {
        if (e && e.statusCode === 0x6a80) {
            // this case happen when the plugin name is too short or too long
            return false;
        }
        else if (e && e.statusCode === 0x6984) {
            // this case happen when the plugin requested is not installed on the device
            return false;
        }
        else if (e && e.statusCode === 0x6d00) {
            // this case happen for older version of ETH app
            return false;
        }
        throw e;
    });
}
function setPlugin(transport, data) {
    var buffer = Buffer.from(data, "hex");
    return transport.send(0xe0, 0x16, 0x00, 0x00, buffer).then(function () { return true; }, function (e) {
        if (e && e.statusCode === 0x6a80) {
            // this case happen when the plugin name is too short or too long
            return false;
        }
        else if (e && e.statusCode === 0x6984) {
            // this case happen when the plugin requested is not installed on the device
            return false;
        }
        else if (e && e.statusCode === 0x6d00) {
            // this case happen for older version of ETH app
            return false;
        }
        throw e;
    });
}
//# sourceMappingURL=Eth.js.map