"use strict";
exports.__esModule = true;
exports.decodeTxInfo = void 0;
var rlp_1 = require("@ethersproject/rlp");
var bignumber_js_1 = require("bignumber.js");
function decodeTxInfo(rawTx) {
    var VALID_TYPES = [1, 2];
    var txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;
    var rlpData = txType === null ? rawTx : rawTx.slice(1);
    var rlpTx = (0, rlp_1.decode)(rlpData).map(function (hex) { return Buffer.from(hex.slice(2), "hex"); });
    var chainIdTruncated = 0;
    var rlpDecoded = (0, rlp_1.decode)(rlpData);
    var decodedTx;
    if (txType === 2) {
        // EIP1559
        decodedTx = {
            data: rlpDecoded[7],
            to: rlpDecoded[5],
            chainId: rlpTx[0]
        };
    }
    else if (txType === 1) {
        // EIP2930
        decodedTx = {
            data: rlpDecoded[6],
            to: rlpDecoded[4],
            chainId: rlpTx[0]
        };
    }
    else {
        // Legacy tx
        decodedTx = {
            data: rlpDecoded[5],
            to: rlpDecoded[3],
            // Default to 1 for non EIP 155 txs
            chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from("0x01", "hex")
        };
    }
    var chainIdSrc = decodedTx.chainId;
    var chainId = new bignumber_js_1.BigNumber(0);
    if (chainIdSrc) {
        // Using BigNumber because chainID could be any uint256.
        chainId = new bignumber_js_1.BigNumber(chainIdSrc.toString("hex"), 16);
        var chainIdTruncatedBuf = Buffer.alloc(4);
        if (chainIdSrc.length > 4) {
            chainIdSrc.copy(chainIdTruncatedBuf);
        }
        else {
            chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);
        }
        chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);
    }
    var vrsOffset = 0;
    if (txType === null && rlpTx.length > 6) {
        var rlpVrs = Buffer.from((0, rlp_1.encode)(rlpTx.slice(-3)).slice(2), "hex");
        vrsOffset = rawTx.length - (rlpVrs.length - 1);
        // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.
        if (rlpVrs[0] > 0xf7) {
            // Increment vrsOffset to account for that extra byte.
            vrsOffset++;
            // Compute size of the list length.
            var sizeOfListLen = rlpVrs[0] - 0xf7;
            // Increase rlpOffset by the size of the list length.
            vrsOffset += sizeOfListLen - 1;
        }
    }
    return {
        decodedTx: decodedTx,
        txType: txType,
        chainId: chainId,
        chainIdTruncated: chainIdTruncated,
        vrsOffset: vrsOffset
    };
}
exports.decodeTxInfo = decodeTxInfo;
//# sourceMappingURL=utils.js.map